\chapter{Single Board Computer Programming Basics}
	<TODO Chapter Single Board Computer Programming Basics : PROOF READ>

Once you get your \ac{SBC} in the mail and you open it up what do you do? You read the getting started guide, you plug in the the \ac{SD} card, plug in a monitor, plug in a keyboard and mouse. The \ac{SBC} boots up to a Linux desktop or command line and waits for your input. 

This Chapter is about what you can do with the \ac{SBC} after it boots up. There are many projects you can do with the \ac{SBC} and we will discuss the most popular \ac{SBC}, the \ac{RPi}. We will show examples of how to use the \ac{RPi} but most of the examples here apply to any Linux distribution. 

\section{Linux Basics}
	<TODO Section Linux Basics : PROOF READ>

The first thing that you will need to get used to in Linux is the command line. At the command line the programmer types in the commands they want to run. In this interface processing power is not wasted on rendering the \ac{GUI} or handling \ac{UI} events. The overhead of a \ac{GUI} takes away from processing the tasks you are trying to perform. 

Next we will introduce aliases to make issuing common commands easier. Aliases allow you to use a shorter phase for common commands you execute, this is particularly helpful if the commands being ran have many parameters that are the same. Aliases save keystrokes per command, so long commands that are ran frequently are usually first to be aliased. 

We will then turn to the concept of \emph{Cron-Jobs}. In Linux we can setup a Cron-Job that can be ran any interval with a one minute resolution. Once scheduled, a script can be ran to scan for malware, move files, or clean up some old data. A good candidate script for a Cron-Job is one that needs regularly ran and takes a while to perform. 

Finally we discuss popular programming languages. We will discuss the basics of three languages. The first we look at C/C++. The strength of C/C++ is that it is a low level language with a high efficiency rating. Next is Python, which is gaining a lot of popularity, particularly in machine learning applications. Since Python is more abstract from bare metal we sacrifice efficiency but we gain a lot from Python. Finally, we discuss a newer language named \emph{Julia}, which shows many promising attributes.  
	
\subsection{The Terminal}
	<TODO Subsection The Terminal : PROOF READ>
	
The Linux \ac{CLI} is a very power full tool. We will start with the basics here and once you are comfortable with the process you productivity will increase dramatically. Most people like the comfort of using a \ac{GUI} because they feel like they don't have to remember all the commands to type in. If they search through the menus long enough they will find the menu button they are interested in. Once comfortable with the \ac{CLI} this process of searching for the command you want to run is faster. 

We first just need to get past the learning curve of the \ac{CLI}.  To start with we will \emph{list} all the files that are in the current working directory. We can do this by opening a terminal and running the command:

\begin{lstlisting}[language=bash]
    $ ls
\end{lstlisting}	
	
After the command completes you will have a printout of all the file names in the directory you are currently in. When you open the terminal program the folder you are most likely to be in is your \emph{home} directory. We can confirm this by issuing the command:

\begin{lstlisting}[language=bash]
    $ pwd
\end{lstlisting}	

The command \emph{pwd} stands for print working directory and once this command executes the absolute path of your current working directory is printed. If you are in your \emph{home} directory you will see you are in a folder named by your \emph{user name}. 	
	
The \ac{CLI} is used to call programs, ones we write ourselves and ones we have installed. As we write our own programs we will want to organize the files of code into directories, at the \ac{CLI} we can make a directory by running the command:

\begin{lstlisting}[language=bash] 
    $ mkdir test
\end{lstlisting}	

After executing the command we will have a new directory in our current working directory call \emph{test}. The \emph{mkdir} command takes in a parameter, namely the new directory's name, and makes a directory with the name. So this command can be ran again with any string after the \emph{mkdir} command and a folder will be produced as a result. 

Once we have made the directory we will need want to change directories into the \emph{test} folder. To do this we can run the \emph{cd} command:

\begin{lstlisting}[language=bash]  
    $ cd test/
	$ ls
\end{lstlisting}

Once we run the \emph{cd} command with the folder name as a parameter we change our working directory. To see what is in this folder we can issue \emph{ls} again. Since we just made this directory the folder is empty. 

In our test folder we can make an empty file by running:

\begin{lstlisting}[language=bash] 
    $ vim test_file
\end{lstlisting}

Note: Depending on your Linux distribution you may not have \emph{vim} installed. If this is the case, skip to the section about install software

The \emph{vim} command will first make an empty file in the working directory but \emph{vim} is also a text editor. For a more in-depth tutorial of \emph{vim} you can run the command:

\begin{lstlisting}[language=bash]  
    $ vimtutor
\end{lstlisting}

The \emph{vimtutor} command opens up a document, in \emph{vim}, that walks through the basic features of \emph{vim}. Since you are reading the document in \emph{vim} you can practice the keyboard strokes that allow you to interact with the tutorial document. \emph{vim} is a fully configurable and powerful text editor and is preferred by most for programming applications. 

Now that we have ran \emph{vim test\_file} we have a blank file being displayed by \emph{vim}. From here we can type the following commands:

\begin{lstlisting}[language=bash]
    i
    Hello World.
    <esc>
    :x!
\end{lstlisting}

When \emph{vim} is launched we enter in command mode. We first enter \emph{i} which is a \emph{vim} command to go into insert mode. In this mode we can type into the document whatever we would like, in the example we typed in \emph{hello world}. After we are done editing we need to get back into command mode again and to do this we use the escape key on the keyboard. Once back in command mode we issue the \emph{vim} command \emph{:x!} which saves and closes the document, returning us back to the \ac{CLI}.	
	
\subsection{Aliases}
	<TODO Subsection Aliases : PROOF READ>
	
Aliases are used in the bash shell to reduce the number of keystrokes needed to execute common commands. You can defined permanent aliases which are defined even after a power cycle and in different terminal sessions. Alternatively you can define aliases temporarily. We will focus on permanent aliases placed in your \emph{~/.bashrc} file or \emph{~/.bash\_aliases} file, which is called from your \emph{~/.bashrc} file. 

To define an alias we use the syntax \emph{alias name=command}. So for example we can define an alias that adds color to the result of the \emph{ls} command. We define the alias by first opening our \emph{.bash\_aliases} file:

\begin{lstlisting}[language=bash]
	$ vim ~/.bash_aliases
\end{lstlisting}

We then add the line that defines the alias into the file,

\begin{lstlisting}[language=bash]
alias ls='ls --color=auto'.
\end{lstlisting}

We can then save and close the file. Next we need to check that our \emph{~/.bashrc} file calls and runs the \emph{~/.bash\_aliases} file. First we open the \emph{.bashrc} file,

\begin{lstlisting}[language=bash]
vim ~/.bashrc.
\end{lstlisting}

In the \emph{.bashrc} file we check to see if the \emph{.bash\_aliases} file exists and if it is we run the bash script:

\begin{lstlisting}[language=bash]
if [ -f ~/.bash_aliases]; then
	. ~/.bash_aliases
fi
\end{lstlisting}

Now that this code is in our \emph{.bashrc} file we can save and close the file. Once closed the alias that we just defined in the \emph{.bash\_aliases} file hasn't be ran yet. To run the files to get the alias declared we have two options. First is to source the files by running:

\begin{lstlisting}[language=bash]
	$ source ~/.bashrc.
\end{lstlisting}

Or by closing and reopening a terminal. After the scripts have been sourced we can run \emph{ls} like we normally would and we will see color-coded output of the \emph{ls} command. 

Some other useful aliases are:

\begin{lstlisting}[language=bash]
alias reboot='sudo reboot'
alias update='sudo apt-get upgrade'
alias ..='cd ..'
alias mkdir='mkdir -pv'
alias ping='ping -c 5'
alias fastping='ping -c 100 -i .2'
\end{lstlisting}
	
The first two aliases allow you to avoid having to type \emph{sudo} for the common command of \emph{reboot} and \emph{apt-get upgrade}. The next command makes changing to the parent directory easier. The \emph{mkdir} command is aliased to passing in two switches which make directories for all the parent directories that don't exist. With this command we now don't have to make a directory then \emph{cd} to the directory then make another directory. If we know the directory structure we need we can just call \emph{mkdir} once with the full path. 

The last two aliases setup some default parameters for the \emph{ping} command. The first alias for the \emph{ping} command itself sets the number of pings to be five. The second alias is \emph{fastping} which sends $100$ packets but reduces the amount of time in between the transmissions to test the response speed to the destination. 

Presented here are a few aliases that first demonstrate the syntax of defining aliases. Next they offer some ideas on what you could define for aliases. If you find that you are typing a command very often with the same parameters maybe an alias will help making your keystrokes a little more efficient. 
	
\subsection{Cron-Jobs}
	<TODO Subsection Cron-Jobs : PROOF READ>

A Cron-job is a scheduling a script or command, just like you would type into the \ac{CLI}, to run at a specified time. Usually the tasks that are scheduled as a Cron-Job are tedious tasks that may require a lot of time to run and do not need you to supervise them. Tasks that can be started while you are away from your computer and can be finished by the time you come back are perfect candidates for  a Cron-Job scheduling. 
	
One example would be if your work space with subdirectories and data were to be backed up on a server. A Cron-job could be scheduled to copy the files to the server at regular intervals this way you would have backups of your work space based on a date and time stamp. Along the same lines code revision software such as \emph{git} or \emph{subversion} can be automated to ensure proper backups are made and newest code from other team members is integrated.  

Some other examples include monitoring system performance like disk usage scans could be ran regularly. If your computer needs to be rebooted weekly or monthly this could be scheduled so that you don't have to wait for the start up process to take place. Some system administration tasks can be scheduled and maintenance for user groups can be ran when appropriate. Finally, security scans can be performed and patches can be applied without a user's oversight. If you are finding that you are running a utility often and could look at the outputs at a later time a Cron-job can be scheduled. 

To schedule a Cron-job we run the command:

\begin{lstlisting}[language=bash]
   $ crontab -e
\end{lstlisting}
	
If this is your first time running the \emph{crontab} command you will be prompted to setup your preferred editor, we use \emph{vim}. Once configured we are presented with the Cron-Job table of scheduled jobs. To schedule a new job we are going to add a line to the table. The first five parameters of the row setup when and how often the job is ran. The final parameter is the command that is executed. For example 

\begin{lstlisting}[language=bash]
    0 1 * * * python /home/user/copy_files.py
\end{lstlisting}

which runs the python script \emph{copy\_files.py} at 1:00 AM. Next we can look at the contents of \emph{copy\_files.py}. 

\begin{lstlisting}[language=python]
#!/usr/bin/env python
cp -r /home/user/workspace /home/user/backup/
\end{lstlisting}

The python script \emph{copy\_files.py} copies all the files and sub-folders of the user workspace to user backup. 
	
\section{Programming Languages}
	<TODO Section Programming Languages : NOT DONE>

Choosing a programming language first depends on the algorithm or task you are trying to accomplish. Just like using a shovel to dig the foundation for a skyscraper you also wouldn't use a bulldozer to make a sandcastle. It is important to choose the correct tool for the job. 	
	
We are not choosing the best language, we are determining which language, or tool, to use for a specific job. In this section we talk about why you would choose C/C++ (a shovel), or Python (a bulldozer), or a new tool Julia (a shiny new bulldozer with extra features that may get in the way). 	
	
	
\subsection{C/C++ vs. Python vs. Julia}
	<TODO Subsection C/C++ vs. Python vs. Julia : PROOF READ>

In this overview of three languages we start with the \emph{lowest level} language. The term \emph{low level} refers to how close to bare-metal a language is, for example memory access and how memory data is organized in memory. A bare-metal language allows the programmer the ability to store data is physical memory locations. If you are trying to develop a game though you are not concerned where the data is stored in memory so you want a higher level language that abstracts those details from you. 

Memory allocation is just one example of what can be abstracted from the programmer. Some programmers want to have the ability to control where all the data is going and how it is organized. There may be an efficiency to particular organization that may be lost when managed by an \ac{OS}. This overview provides some examples of each language and helpfully allows you to choose the best language for your application.

\subsubsection{C/C++}
	<TODO Subsubsection  C/C++ : PROOF READ>

The C programming language is considered a \emph{high level} language in some embedded processing circles in that the C programming language is compiled down into machine code. The process of compiling the C code into machine language takes a few interpretive steps in which some functionality are abstracted from you as the programmer. These abstractions are beneficial in terms of getting pass the minor details of a program and getting to the functionality of the program itself. 

Just like in physics the terms \emph{high} and \emph{low} are relative; just as they are here. In the section we will consider the C language to be a \emph{low} level language. We justify the \emph{low} level distinction by considering the fact that C is the preferred language for small embedded processors with varying architectures. Due to the varying architectures of the \ac{ARM}, \ac{RISCV}, \ac{ATMEGA}, \ac{MIPS}, and \ac{TI-DSP} the C compiler, \ac{GCC}, is altered to consider the changes in architecture. Since the architecture does have an effect, we consider the C compiler to handle low level or hardware level changes. 

To get started with writing a C program we first look at the \emph{hello world} example program. First we include the C library stdio. The standard input and output library allows us to read from the keyboard and also write to the screen. In the \emph{hello world} example we will print to the screen with the function \emph{printf}. Next we define the \emph{main} function. When the program is launched main is where the program starts.

Finally we call the \emph{printf} function with passing in the string we want to print to the console. Once we have a file named \emph{hello\_world.c} with the lines of code:

\lstinputlisting[language=C]{../code/c/helloworld.c}

We can compile and execute the program next. First we need to compile the file by using \ac{GCC}. We can do this at the \ac{CLI} by first checking of \ac{GCC} is installed by issuing the command: 
	
\begin{lstlisting}[language=bash]    
	$ gcc --version
\end{lstlisting}
	
Which will print out the version of \ac{GCC} that is currently installed. If the command errors out and says that the command is unknown we need to install \ac{GCC}	
	
\begin{lstlisting}[language=bash]$ 
	sudo apt-get install gcc -y.
\end{lstlisting}

This command installs the necessary dependencies and answers yes to all questions like if it is ok to download the install files while citing the size for you.

Once we have a working installation of \ac{GCC} we can compile the \emph{hello\_world.c} file by issuing:

\begin{lstlisting}[language=bash]
    $ gcc hello_world.c 
\end{lstlisting}

If there are any syntax errors the compiler will print them out. If there are no errors then \ac{GCC} will have made an \emph{a.out} file. We can then run the program by running,

\begin{lstlisting}[language=bash]
    $ ./a.out 
\end{lstlisting}

which prints the string "Hello World" to the console. If you don't like the default name of \emph{a.out} you can compile the source code with:

\begin{lstlisting}[language=bash]
    $ gcc -o helloworld hello_world.c 
\end{lstlisting}

In this case if there are no errors \ac{GCC} will make a file called \emph{helloworld}. We then can run our program by,

\begin{lstlisting}[language=bash]
    $ ./helloworld
\end{lstlisting}

Moving on to an example that is a little more complicated. We can convert binary to decimal and vice-versa. We will first include \emph{stdio} again along with the \emph{math} library. Next we use a \emph{\#define} declaration to improve code read ability and to increase code reuse. We will define the number of bits we use for our conversions with \emph{\#define NBITS} so that if we want to change the bit width we can change it in one place. All the code that depends on the number of bits references the \emph{\#define}.

After the \emph{\#define} we define our first function, \emph{print\_vec}. The \emph{print\_vec} function prints the integers that are in the integer array pointer that is passed in. In this case the number of integers to be printed out is $NBITS$ that we defined earlier. At the end of the function we print a \emph{line-feed} character to move to a new line. 

Next we will look at a function that takes in an integer pointer. The integer pointer points to $NBITS$ integers that represent a binary string. Even though the type is integer we assume that each element is either a one or zero. To calculate the decimal value of the binary vector we assume the \ac{LSB} is bit $0$. We initialize two integers $i$ and $sum$ to $0$. Then we loop over $i$ up to $NBITS$ and use the $sum$ variable as a running sum. The running sum will be the decimal value which at the end of the function is returned to the caller of the function. 

To calculate the decimal value we loop over the binary array. Each element of the array is either a $0$ or $1$. Each position of the binary array has a weight of $2^i$ where $i$ is the bit position. For example, position $0$ has a weight of $2^0 = 1$, if bit zero, denoted in the C code as $b[0]$ is one then we add a one to the running sum, otherwise zero is added. We continue this process up to $NBITS$, in which at the end $sum$ is the decimal value of the binary array.

The next function in the file is converts a decimal value to a binary array. In this function we have two parameters. The first the the decimal value that we are converted, denoted $d$. The second parameter is the binary array result. Since the point is being passed to this function we will update the section of memory that the point points to then after returning from the function call the caller will know that the pointer is updated with the correct result. 

Since we assumed that the \ac{LSB} is bit zero, and for converted a decimal value to binary we need to start with the \ac{MSB} we set up another for loop but we initialize the loop variable $i$ to $NBITS$ and decrement  each time through the loop. To determine if bit $i$ is a zero or one we check to see if the bit position's weight is less than the current value of $d$, if so then the bit is a one, otherwise a zero. If the position weight does subtract to leave a positive number, making the bit a one, we also need to reduce $d$ by that bit position's weight before moving on to the next iteration. Once complete the function returns. 

Finally we get to the \emph{main} function. The \emph{main} function is the first one called when a program is executed. When first learning it is hard to understand why the \emph{main} function isn't placed at the top of the file. We place the \emph{main} function at the bottom of the file because the compiler has to have the functions defined before they can be used. Since all the functions will be used in our main we keep our \emph{main} at the end of the file. In larger programs you can include a header file that declares all the functions that will be defined so that they can be called in any other function. 

The first three lines of code in our \emph{main} file declare an integer array named $b$ and two integers $i$ and $sum$. We use $i$ as our for loop variable again and we loop from $0$ to $2^{NBITS}-1$, the minus one is accomplished by the strictly less than conditional, which tests the full range of integers with $NBITS$. 

For each iteration we convert the loop variable $i$ to binary with our \emph{dec2bin} function then pass the binary array to our \emph{bin2dec} function. We then compare the result of the \emph{bin2dec} with the loop variable. If they are not the same then we have a problem and we print to the console saying that we have an error.

Once the loop is done we write to the console that we are complete and return $0$. The return $0$ for \emph{main} tells the \ac{OS} that we finished with no errors. If we had a larger program with many different ways of failing we could use return values to help us debug what went wrong. 

\lstinputlisting[language=C]{../code/c/bin2dec/bin2dec.c}

Just like with the hello world example we need to compile and run the code. First we issue:

\begin{lstlisting}[language=bash]
    $ gcc -o b2d bin2dec.c -lm
\end{lstlisting}

We named our executable \emph{b2d} and specified our source code file just like before. This time though we need to pass in the switch \emph{-lm} since we are using the math package. We need to tell the compiler to link in the math package to our executable.

The last example for the C programming language looks at how we can save data. We will look at how to read and write data to a file. The file will persist after the program has ended and the data can be read back when a program starts so we can keep track of data that was previously generated. 

For our file \ac{IO} example we will be reading in a text file. If you want to run the example you will need to create a text file. We named ours \emph{test.txt} and we added some sentences to the file, anything will do. 

The first two lines of code in our file \ac{IO} example our header files that we will be using just like in the previous examples. We define our $LINESIZE$ which is used for reading the text file. The $LINESIZE$ is the maximum number of characters in a single line in the file. This is so that we can preallocate an array to hold all the characters. 

The first helper function we have is an \emph{alpha\_init} function that has a return type of \emph{void}. The one parameter is a character array of $26$ in length. All this function does is initialize the array to the $26$ lower case letters in the alphabet. 

Next we have a helper function that prints out all the characters in a character array. There are two ways for the printing to end. We can reach the $LINESIZE$ length which is the maximum line size. We could also reach the new line character. The new line character denotes when a string is terminated. The termination character is used so that as we have varying length strings we are ended when we need to instead of printing out uninitialized memory as \ac{ASCII} characters. 

Moving on we have a function that counts the number of vowels in a character buffer. Here we loop over the buffer; up to $LINESIZE$. If the current character, denoted \emph{buff[i]}, is a vowel we increment a counter. Once complete we return the counter. 

Before we get to the main function we will look at one last helper function. The \emph{caesar\_cipher} is a cipher that was used a long time ago. If offers no security level but is a good example problem for string manipulations. 

The Caesar Cipher takes in plain text and a key. The key is an integer from $1$ to $25$. A key of $1$ means that for ever letter you replace it by the next one in the alphabet. So an \emph{a} becomes a \emph{b} and so forth. If the key is $3$ then an \emph{a} is mapped to \emph{d}. Spaces are kept as is which is one of the reasons why the cipher has no security. Lets look at a function that calculates the cipher result for a given character array. 

The caesar\_cipher function takes in three parameters, two character arrays one for input (\emph{buff}) and one for output (\emph{cc}), and the integer key. In the function we first define some integers and a character array for storing a copy of the alphabet. 

Next we call the \emph{alpha\_init} function that we discussed earlier. Then we start the loop over the characters in the input buffer. There are a couple of cases that we need to check for per character in the array. We need to know if the line has ended, if there is a space, and finally if we are at a letter that needs encoding. 

If the line has ended that means we have reached the new line character. So if we have reached the new line character we put the new line character in our Caesar Cipher result string, \emph{cc}. We also assert the \ac{EOL}, \emph{eol}, variable. Keeping track of the \emph{eol} variable allows us to not check the rest of the line. We also had some other special characters in our test file so we included those as our stop condition. 

If the current character is a space we detect that and put a space in our \emph{cc} result. And finally we need some logic to determine what character will replace the letter that is currently being considered, \emph{buff[i]}. 

To start will will loop over the \emph{alpha} array to determine which letter \emph{buff[i]} is. If \emph{buff[i]} is \emph{alpha[a]} then we know which letter we are at. Next we can add the $key$ variable to $a$ to get the new index into \emph{alpha}. If the new index overflows the $26$ letters in \emph{alpha} we can use the \emph{modulus} operator to wrap around at $26$ to ensure the correct indexing behavior.

Now that we are done with all the helper functions we can look at the \emph{main} function. The \emph{main} function takes in two parameters the integer $argc$, which is the number of command line parameters. The second is parameter is a character double pointer. These parameters are how the command line parameters will get to our application. We can use these parameters for specifying the file name that we will read from. 

We next initialize from variables including the file pointer. Then we use the \emph{fopen} function to open the file that was specified in the command line parameters. The string \emph{argv[0]} is the name of the file and \emph{argv[1]} is the first parameter issued by the user. Now we loop over the lines in the file. We can continue looping until the end of the file is reached. Once \ac{EOF} is reached the \emph{fgets} function return \emph{NULL} and we are done with the file. 

The \emph{fgets} function takes in a buffer, the size of the buffer, and the file pointer. Once called in the while loop conditional the \emph{buff} variable is filled with the next line in the file. 

Each loop though the file we count the number of vowels can calculate the Caesar Cipher for a key of $1$. We then print out the cipher result for visual inspection. After the end of the loop we print out the number of vowels we found and close the file, releasing the resources back to the \ac{OS} for the file. 

\lstinputlisting[language=C]{../code/c/fileio/fileio_example.c}

Once again we went through the file from the top down. We understand that as we go though the file we first look at all the functions that will be helpful to us when we write our \emph{main} function. This methodology presents the example easily but do keep in mind this isn't how this example was written. 

From scratch we would start with a declaring a \emph{main}. We also increase the complexity of the program by starting off with the hello world program. Make sure you have your environment setup correctly so you can compile and run your program. Then break down the problem into small steps. As you develop working code in your \emph{main} function you can move the code to a function. Its especially useful to do this if you find that your are copying code that you already wrote. If you make a function out of it you can just call that function many times. 

As you develop more code and more complex programs you will see you code base grow so that you don't have to rewrite code all the time you can start called your other functions so you can spend your time write new more complex functions. 

\subsubsection{Python}
	<TODO Subsubsection  Python : NOT DONE>

Now we will transition from C to Python. The biggest difference between the two languages is the use of indentation for code scope. In C curly-brackets are used for scope differentiation. For example, after an if statement the code that is executed distinguished by using $\{\}$. In Python we end the if statement conditional with a colon, then the indentation marks the scope for the conditional. 

Getting started with our first example in Python we will look at the hello world program. The first line in \emph{helloworld.py} is the directive. Which tells the \ac{OS} what type of interpretor to use for the file. The next line prints are message to the console. 

\lstinputlisting[language=Python]{../code/python/helloworld.py}

To run the python script we can go to the command line and execute

\begin{lstlisting}[language=bash]
    $ ./helloworld.py
\end{lstlisting}

or if you'd like to exclude the environment directive you can exclude the first line and run the script as

\begin{lstlisting}[language=bash]
    $ python3 helloworld.py.
\end{lstlisting}

We may need to install Python 3 if the above commands error out. We can do this by using the package installer with the following command:

\begin{lstlisting}[language=bash]
    $ sudo apt-get install python.
\end{lstlisting}

Once we have python installed and we can run the hello world application. We can move on to our next example. In this example we use the random package to generate a dice roll. The dice roll is uniformly distributed over the range $[1,6]$. 

We can generate a random dice roll by first importing the random package. We do this with the first statement in \emph{diceroll.py} after the environment directive. The statement \emph{from random import *} means that from the random package we will import everything. 

The next statement in the code generates a random number. We use the \emph{randint} function in the random package. The \emph{randint} function takes in two parameters. The first parameter is the lower limit of the random number to be generated. The lower limit is included and can be generated in the result, so we provide a $1$. The second parameter is the excluded upper limit. Since we are using a random integer and we provide the upper limit of $7$ the highest number generated will be a $6$. 

Once the \emph{randint} function is ran the variable $r$ is assign our generated dice roll. We then will print the result to the screen just like with did in the \emph{hello world} example. To print the random number, $r$, we need to cast the numeric value to a string that can be printed to the screen. We do this with the \emph{str} function. We then concatenate the result with a string of our own to display the result to the screen.
	
\lstinputlisting[language=Python]{../code/python/diceroll/diceroll.py}

We have seen how to print strings to the console and how to import Python packages. With our third and final Python example we will look at how to make a text based game. We kept the game trivially simple for illustrative purposes. 

The text based game is played at the \ac{CLI}. When we start the game we get a game status then are prompted on how to playa the game. The game blocks on keyboard input from the user then depending on what the user inputs the game takes appropriate action and then displays the new status of the game and prompts the user again. These actions are repeated until the game is over or the user quits. 

The example code imports the math package after the environment directive. Then we move on to displaying status to the user. Three print statements provide the user with updates on how the game the being loaded. If we supported loading a game from a file we could put the file reading under the \emph{Initializing Game} section so the user is not wondering what's wrong as we load data from a file. 

The next section of code initializes two numbers, \emph{total\_money} and \emph{num\_workers}. The premise of this game is to hire more workers to get more money to hire more workers. Each worker gets you a surplus of $2\%$ positive cash. The game starts with $\$50$ and zero workers. 

We also initialize a \emph{skip\_iters} variable along with a \emph{playing} variable. The \emph{skip\_iters} variable is used to keep track of a number cycles through the game. \emph{skip\_iters} is used so that we can avoid typing in commands every time we can just let the workers accumulate money without having to manually do it with the keyboard. The \emph{playing} variable is used to keep track of whether the user is still playing the game. If the user quits the game the \emph{playing} variable is set to zero to quit the game. 

Next we start the \emph{while} loop for continuous game play. Once this loop end the game is over. Next we check to see if we are going to skip this iteration. Since we haven't seen how this variable gets set yet we will just note that the variable is checked here. If we are not skipping this iteration we first print out all the status of the game, which includes the current amount of money and the number of workers employed. 

After the status is printed we then use Python's \emph{input} function to get keyboard input from the player. The \emph{input} function takes in one argument which is the string prompting the player for input. Once the user does input a command and presses enter the command is stored in the \emph{cmd} variable. 

The \emph{cmd} variable is used next in the \emph{if-else} statement to take the action corresponding to the command. So for each command supported we have a conditional checking to see if the command is a particular command. The first command we check for is \emph{a}. If the command received from the player is an \emph{a} then we hire another worker. We print out to the player that we are adding a worker and we subtract $\$25$ as the cost for hiring a worker. 

The next command we check for is the \emph{A} command. This hires as many workers as we can afford. This is handy when we have played the game a long time and we have a lot of money and we don't want to issue the \emph{a} command over and over again. For the \emph{A} command we first determine how many workers we can afford, calculated as \emph{new\_workers}. Then we add the number of new workers to our total number of workers. Finally we deduct the $\$25$ for each worker hired. 

The \emph{s} command is detected next. The \emph{s} command sets the number of iterations to skip to be $1000$. When \emph{skip\_iters} does not equal zero when we do not print the status of the game and we don't ask the user for an input command. When we are skipping the iteration the only two things we do is decrement the \emph{skip\_iters} variable and update the amount of money the workers provide. 

\lstinputlisting[language=Python]{../code/python/textgame/textgame.py}

The rudimentary game presented here is not really a game is the truest sense. To be a game there needs to be a way to lose the game. Here you have no way of losing money or workers. You are guaranteed to eventually make enough money every iteration to hire another worker the next iteration. The easiest way to make this a true game is to keep track of the number of iterations it takes you to get to a certain dollar amount, some number of workers, or a combination. 

There are some basic features left out of this example that should be incorporated. What happens if you want to hire a worker but don't actually have enough money for hire one. The worker is still hired and you have negative money. This action probably shouldn't be allowed. As a general rule all user input should be validated. This way the rules that you set in your game have to be followed. 

You could also have the player specify the number of iterations they want to skip in the command. So instead of issueing the command \emph{s} they could issue \emph{s 100} or \emph{s 10000} that way the player would have a finer control of the money being accumulated. 

Some improvements on the game can be to introduce more complex workers. This could mean that for a more expensive worker the produce more money per iteration. Or maybe you can add a number of open positions and you can't hire more than the number of open positions. In this case how would you determine whether a positio should be opened up. Maybe the workers make widgets that are sold. As more widgets sell the need for more workers with a higher production rate are needed. If sales go down we will need to lay people off. 

As we get a more and more complex game we could probably use the ability to save the game off to resume later. Here we could write all the needed status to a file, then when the game is resumed we read the file back out and update our status with what's in the file. This way we can pick up where we left off. 

There are many ways to improve this shell of a game. The game can be taken in may directions. The best way to learn Python or any programming language is to get started. Adding a couple features to this game is a great way to get started. Once you add a few features play the game and see if you can think of ways to make the game more realistic, or even less realistic but fun.

\subsubsection{Julia}
	<TODO Subsubsection  Julia : NOT DONE>

\section{Controlling GPIO}
	<TODO Section Controlling GPIO : NOT DONE>

