\chapter{What is a Single Board Computer}
	<TODO Chapter What is a Single Board Computer : NOT DONE>

\section{Parts of a Single Board Computer (SBC)}
	<TODO Section Parts of a Single Board Computer (SBC) : NOT DONE>

\subsection{Microprocessor(s)}
	<TODO Subsection Microprocessor(s) : NOT DONE>

\subsection{Memory}
	<TODO Subsection Memory : NOT DONE>

\subsection{Input and Output}
	<TODO Subsection Input and Output : NOT DONE>

\section{Applications for SBCs}
	<TODO Section Applications for SBCs : PROOF READ>
	
The number of applications for \ac{SBC}s is enormous. The rise of the raspberry pi and many similar boards have popularized home makers tinkering with boards. New applications are being developed every day.  Below we list seven popular applications. The first being retro gaming platform. You can play Atari games or most platforms on a \ac{SBC} with an emulator installed on you \ac{SBC}. You can host a small web-server. Have you ever wanted to make a website but didn't want to pay for web hosting. An \ac{SBC} can host a site on you \ac{LAN} for free. You can also make an Amazon echo, a Christmas light show, a time clock based on facial recognition, and a stock ticker. The last application we discuss is how we can use a \ac{SBC} as a test vector generator for an \ac{FPGA}. 

\subsection{Retro Gaming}
	<TODO Subsection Retro Gaming : PROOF READ>
	
It's no surprise that processors are faster now than where they were in the 1980's. Original gaming consoles were had eight bit processors and ran in the single digit megahertz range. For a lot of people that are interested in embedded processing on a \ac{SBC} and \ac{FPGA} they grew up with these types of systems. The exciting part of growing up with these systems is getting to play them again. For people who want to understand how they work they platform is there to support it.

Clearly our \ac{SBC} platform must be of higher performance than the retro game console that we are going to emulate. On the \ac{SBC} we can limit ourselves to use less \ac{RAM}. We can burn clock cycles to emulate a lower clock speed. We are starting with an \ac{SBC} that has a \ac{CPU} that operates at hundreds of \ac{MHz} and has \ac{GB} of \ac{RAM}. To emulate the Atari 2600 which has a \ac{CPU} that runs at 1.19 \ac{MHz} and has 128 Bytes of \ac{RAM}.

\subsection{Small Web Server}
	<TODO Subsection Small Web Server : PROOF READ>

Most people think of a web server as large rack mounted blade servers that can handle thousands or millions of web-pages hits per hour. The web-server doesn't have to be that large to be useful. A website hosted on your \ac{SBC} can help you learn networking skills, how to program in website building programming languages (JavaScript, \ac{HTML}, \ac{CSS}, MySQL etc), it can even be a great way to have a \ac{UI} for your other projects were you control \ac{GPIO} over the network.

\subsection{Amazon Echo}
	<TODO Subsection Amazon Echo : PROOF READ>
The Amazon echo with the Alexa powered speech processing engine is a popular gadget. Amazon has made the engine available, if you register, to interested developers. Now you can turn a Raspberry Pi into a Amazon echo. 
	
	
\subsection{Christmas Light Show}
	<TODO Subsection Christmas Light Show : PROOF READ>

A \ac{SBC} is the perfect platform to a automate home Christmas lights display. The connectivity of the \ac{SBC} to a \ac{LAN} makes controlling the lights easily accessible. The number of \ac{GPIO} available is usually plenty. The processing doesn't have to be fast and a \ac{SBC} is plenty fast enough to create any flashes for lights your eyes can see. 
	
	
\subsection{Facial Recognition Time Clock}
	<TODO Subsection Facial Recognition Time Clock : PROOF READ>

Usually a time clock has employees clock in with a time card or an employee number. The use of a \ac{SBC} can make clocking in and out easier. The amount of time it takes to clock in can be measured in milliseconds; so the \ac{SBC} can compare a picture, input, to the database of current employees. 
	
\subsection{Stock Ticker}
	<TODO Subsection Stock Ticker : PROOF READ>

In general a great application for an \ac{SBC} can be used to scrape the Internet for data useful to a user. A specific example of this would be getting current stock prices regularly. Yahoo finance makes this fairly simple to where you can get stock price updates on only the stocks you are interested in. 
	
	
\subsection{FPGA Test Vector Generator}
	<TODO Subsection FPGA Test Vector Generator : PROOF READ>

The \ac{FPGA} test vector generator is an application for the \ac{SBC} that we will look at extensively in this book. There is a lot of thought that needs to go into designing a general test vector generator. We hope to be able to use a \ac{SBC} to test our image processing and wireless communication algorithms. Also we would like to be able to use it to test machine learning algorithms all on the \ac{FPGA} with very little effort. We want to spend our time developing the applications not having a lot of time sunk into the automation of testing.

Since we will be using the test vector generator on multiple projects we are going to take the time to design it well. We will focus considerably on flexibility with the goal of minimal tailoring to specific applications. In some cases. for example we would be interested in the latency or execution time of the algorithms developed on the \ac{FPGA} for this we will need the ability to finely control when the algorithm starts working on the data. 

Another aspect that affects execution speed is how quickly can we supply data to the \ac{FPGA} from the \ac{SBC}. The easiest way is to use a \ac{SPI} bus. The \ac{SBC} already supports the protocol with a python library. Which we can generate our test vectors in python and send them over \ac{SPI} to the \ac{FPGA}. The \ac{SPI} bus can operate around $25$ \ac{MHz} if the \ac{FPGA} algorithms need to be tested at a higher data rate we can pre-load the data into \ac{DDR}. 

If we plan to pre-load data into \ac{DDR} there are a few things to consider. First the size of the \ac{DDR} that is interfaced to the \ac{FPGA} it may be possible to preload multiple test vectors into \ac{DDR}. Doing this may save time due to the overhead of setting up data transfers. We would also need to consider how large one test vector is for a particular application. Some applications like image or video processing would require more data than wireless communications data.

In general pre-loading data into \ac{DDR} is going to be a quick way of getting test vectors into the \ac{FPGA}. Once loaded the speed of \ac{DDR} will be fast enough to test our \ac{FPGA} algorithms. Another goal of the test vector generator is to set up a closed-loop self-testing setup where python can setup the test vector, send the data to the \ac{FPGA} then the \ac{FPGA} generates the outputs and sends the results back to the \ac{SBC}. Once the results are received then python can generate performance metrics based on the inputs and outputs. Python would check the results from the \ac{FPGA}. Once closed-loop test is developed then hundreds of thousands or millions of test vectors can be generated and tested.

Testing the \ac{FPGA} algorithms with many test vectors is a fantastic way to ensure there aren't any latent issues with the design. In \ac{FPGA} development there could be minor errors or corner cases that aren't found unless a lot of testing is done. The \ac{SBC} is a great way of automating the test. The faster we can turn over the test vectors the faster we can test hundreds of thousands or millions of test vectors. 

