\chapter{Hello World and Other Projects}
	<TODO Chapter Hello World and Other Projects : PROOF READ>

There is no better way to get started than to work on a small project. This chapter outlines small projects to work on where each of them gets a little more challenging. As you progress through this chapter you will ensure your development environment is setup properly with simulating the hello world project. You will learn how to use a clock in a design and control an \ac{LED}. Then you will learn how to transfer data into and out of the \ac{FPGA} chip. 
	
	
\section{Beginner Projects}
	<TODO Section Beginner Projects : PROOF READ>

Everyone has to start somewhere. These projects are designed to start off slowly. It may not be very exciting to add one to a counter but these exercises get you used to writing \ac{VHDL} and the development environment. Work through these exercises so that when we can get to exciting projects you won't be frustrated with working with the tools. 
	
\subsection{Hello World}
	<TODO Subsection Hello World : PROOF READ>

When learning a new language you always need to write the hello world program. There are two lessons from this project. First, setting up and interacting with the features of your simulator. Once you write the first draft of your program you go through the steps of compiling and simulating your design. You will use this process many times. Gain an understanding of keyboard short cuts and practice them. Make changes to your file and recompile and ensure the changes are reflected when you re-simulate.

The other main take-away from this example is the use of the report function. The report function allows you to print strings out to the console. The report function can be used to print out values of signals to make sure the simulation is progressing like you want in a larger more complex simulation. Or it can be used to report progress of the simulation.      

\begin{VHDLlisting}[tabsize=8]
library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;
  
entity hello_world is
end entity hello_world;

architecture tb of hello_world is
begin
	process
	begin
		report("Hello World!");
	end process;
end tb;
\end{VHDLlisting}
	
	
\subsection{Counter Test-Bench}
	<TODO Subsection Counter Test-Bench : PROOF READ>

In this exercise we will instantiate a \ac{DUT} in a testbench. The \ac{DUT} itself is a simple counter. We will provide a clock to the counter and a reset line that will reset the counter. We will also have an enable line that turns the counter on. A simple \ac{DUT} like this has a few inputs that will need to be driven by the testbench.      
	
\begin{VHDLlisting}
library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;
  
entity tb_counter is
end entity tb_counter;

architecture tb of tb_counter is
	signal w_clk         : std_logic := '0';
	signal w_rst         : std_logic := '0';
	signal w_en          : std_logic := '0';
	signal w_count_sync  : unsigned(7 downto 0):=(others => '0');
	signal w_count_async : unsigned(7 downto 0):=(others => '0');

begin
	p_gen_stim : process
	begin
		w_rst <= '1';
		wait for 37.9 ns;
		w_rst <= '0';
		
		wait for 10 ns;
		w_en <= '1';
		wait for 50 ms;	
	end process;
	
	u_counter_sync : entity work.counter_sync
	port map(i_clk    => w_clk,
			 i_rst    => w_rst,
			 i_en     => w_en,
			 o_count  => w_count_sync
	);
	
	u_counter_async : entity work.counter_async
	port map(i_clk    => w_clk,
			 i_arst   => w_rst,
			 i_en     => w_en,
			 o_count  => w_count_async
	);
	
	p_clk : process
	begin
		wait for 5 ns;
		w_clk <= not w_clk;
	end process;
end tb;
\end{VHDLlisting}

In our testbench we have a process that generates the timing for the input signals. This testbench is only as good as the assumptions made in the timing between signals. If there is a race condition or an inter-timing bug in the \ac{DUT} that the testbench does not cover then the \ac{DUT} will pass the testbench giving you confidence in the \ac{DUT}. Then you have the worst case scenario: debugging a flaky build on hardware. So we need to make sure we make our code reliable to ensure there are no race conditions. In this exercise we look at two examples of a counter. The only difference in the two examples is how the reset is handled, synchronously or asynchronously. We will explain the considerations needed when using this counter in a higher level block.      

\begin{VHDLlisting}[tabsize=8]
library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;
  
entity counter_sync is
port(i_clk   : in    std_logic;
	 i_rst   : in    std_logic;
	 i_en    : in    std_logic;
	 o_count :   out unsigned(7 downto 0)	
)
end entity counter_sync;

architecture rtl of counter_sync is
	-- Output Register
	signal f_count : unsigned(7 downto 0) := (others => '0');
begin

	-- Assign Outputs
	o_count <= f_count;

	p_count : process(i_clk)
	begin
		if rising_edge(i_clk) then
			if i_rst = '1' then
				f_count <= (others => '0');
			elsif i_en = '1' then
				f_count <= f_count + 1;
			end if;		
		end if;
	end process;
end rtl;

\end{VHDLlisting}
	
First the synchronous reset counter. We see in the code that the reset is inside the rising\_edge(i\_clk) if statement. That means that the reset can only happen synchronous to the i\_clk. We can see that both the reset and enable are synchronous. In general synchronous logic is preferred since the vendor tools ensure the propagation delays between the registers are short enough to avoid erroneous results.


\begin{VHDLlisting}[tabsize=8]
library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;
  
entity counter_async is
port(i_clk   : in    std_logic;
	 i_arst  : in    std_logic;
	 i_en    : in    std_logic;
	 o_count :   out unsigned(7 downto 0)	
)
end entity counter_async;

architecture rtl of counter_async is
	-- Output Register
	signal f_count : unsigned(7 downto 0) := (others => '0');
begin

	-- Assign Outputs
	o_count <= f_count;

	p_count : process(i_clk)
	begin
		if i_arst = '1' then
			f_count <= (others => '0');
		elsif rising_edge(i_clk) then
			if i_en = '1' then
				f_count <= f_count + 1;
			end if;		
		end if;
	end process;
end rtl;

\end{VHDLlisting}
	
There are situations when you have to use asynchronous resets. If we assume we will use this counter in a situation where we have to use an asynchronous reset we would write this block slightly differently where the reset line is used outside the clocked region of the process. Now if the i\_reset line changes or the i\_clk line changes the process executed but there doesn't have to be a rising\_edge event for the reset to apply. There is potential issue with instantiating this block with an asynchronous reset. It is possible that the reset fails timing. If the asynchronous reset is applied right before a clock edge where the counter is enabled there could be a mismatch between the expected value in the counter and the registered value. Unfortunately, the vendor tools can't warn you about the asynchronous reset failing timing since it isn't under a clocked process. The vendor tools can't know the timing of the asynchronous reset.	
	
	
	
\subsection{Blink Led with a One Second Interval}
	<TODO Subsection Blink Led with a One Second Interval : PROOF READ>

In the project you will write \ac{HDL} to blink an LED. The LED should be on for a second and off for a second. You will also need to write a testbench for the block. You will find that it will take a long time to simulate a block for multiple seconds. We will once again have a synchronous reset, enable, and a clock as inputs. The output will be wired up to an LED.

To toggle the output we need to know when a second passes. The only way to mark time passing on an \ac{FPGA} is to count clock cycles. So we can setup a counter to increment when enabled and once we get to a certain number of clock cycles we can toggle the output. 

\begin{VHDLlisting}[tabsize=8]
library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;
  
entity blink_led is
generic(gTOGGLECOUNT : integer)
port(i_clk   : in    std_logic;
	 i_rst   : in    std_logic;
	 i_en    : in    std_logic;
	 o_led   :   out std_logic	
)
end entity blink_led;

architecture rtl of blink_led is
	-- Output Register
	signal f_led   : std_logic := '0';

	-- Duration Counter
	signal f_count : unsigned(31 downto 0) := (others => '0');
begin

	-- Assign Outputs
	o_led <= f_led;

	p_count : process(i_clk)
	begin
		if rising_edge(i_clk) then
			if i_rst = '1' then
				f_count <= (others => '0');
			elsif i_en = '1' then
				f_count <= f_count + 1;
			end if;	

			if f_count = gTOGGLECOUNT then
				f_led <= not f_led;
				f_count <= (others => '0');
			end if;			
		end if;
	end process;
end rtl;

\end{VHDLlisting}

The certain number we need to count to is just the frequency of the clock you re using. Here is a fantastic opportunity to learn about generics. Generics can help you configure a block when instantiated. We could use a generic called gCLKFREQ but if we wanted the output to toggle at a rate other than a second this could be confusing. We will use the generic gTOGGLECOUNT. This way if we know how the counter is used and when instantiated we can set the value accordingly.
	
\begin{VHDLlisting}[tabsize=8]
library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;
  
entity tb_blink_led is
end entity tb_blink_led;

architecture tb of tb_blink_led is
	constant k_TOGGLECOUNT : integer := 100000000;

	signal w_clk : std_logic := '0';
	signal w_rst : std_logic := '0';
	signal w_en  : std_logic := '0';
	signal w_led : std_logic := '0';
begin

	p_gen_stim : process
	begin
		w_rst <= '1';
		wait for 34 ns;
		w_rst <= '0';
		
		wait for 15 ns;
		w_en <= '1';
		
		wait;
	end process;

	u_blink_led : entity work.blink_led
	generic map(gTOGGLECOUNT => k_TOGGLECOUNT)
	port map(i_clk   => w_clk,
		     i_rst   => w_rst,
		     i_en    => w_en ,
		     o_led   => w_led
	);

	p_clk : process
	begin
		wait for 5 ns;
		w_clk <= not w_clk;
	end process;	
end tb;
\end{VHDLlisting}

The testbench is simple with the reset, enable, and clock to generate. The difficult part of this testbench though is how long it will take to simulate. At first when you get the testbench working you don't want to have to wait 30 minutes for the simulation to finish. So at first we will set gTOGGLECOUNT to 10 and make sure the logic works. After getting the simulation two work then we can increase it and make sure the output toggles at the expected rate. 

\section{IO Interfacing}
	<TODO Section IO Interfacing : PROOF READ>
	
This section of projects gets data in to and out from the \ac{FPGA}. The list of projects here are the easiest ways of setting up two way data transfer off the chip. These protocols are popular in interacting with a computer or with other chips on the same board.

Although these projects are simple and great starting exercises you will reuse these blocks a lot when interfacing to different peripherals. We will discuss making these blocks generic so that they can be used with minimal changes on a variety of projects.

\subsection{Universal Asynchronous Receiver-Transmitter (UART)}
	<TODO Subsection Universal Asynchronous Receiver-Transmitter (UART) : NOT DONE>
	
The \ac{UART} is a very common low speed protocol. It's primary use is commanding and controlling the FPGA to do a task when a user issues the command through a general purpose computer. The \ac{UART} is also great for status or debugging what is happening on the \ac{FPGA}.

A \ac{UART} is an asynchronous protocol so there is no clock associated with the data. Since there is no clock or an enable line to know when the data is valid we first need to know the baudrate of the data. It is assumed that the datarate is known between the computer and \ac{FPGA}. Since the datarate is known once we get a bit we will know when the next bit is valid. To know when the first bit is valid the \ac{UART} protocol starts with the receive line high. Data is starting to be transmitted when the line goes low. At the falling edge of the data line we count half the bit duration. Once half the bit duration is reached we check again to make sure the data line is low. If the data line is low then we know we are receiving data. Once we have started the transfer the predetermined number of bits are sent. After the falling edge of data line there is a start bit, a stop bit, and a configurable number of data bits. The start bit is what we used to detect the start of the transfer. Then we count a bit duration for each of the data bits. Finally the stop bit can be ignored or sometimes can be configured as a parity bit.  Now we will look at some \ac{HDL} that performs the above tasks. We will use a state machine for this since it is easier to read. 

	
	
\begin{VHDLlisting}[tabsize=8]
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity uart_rx is
  generic(g_baudRate : integer := 115200;
          g_clkRate  : integer := 50000000);
  port(
      i_clk           : in    std_logic;
      i_rx            : in    std_logic;
      o_rx_data       : out   std_logic_vector(7 downto 0);
      o_rx_data_rdy   : out   std_logic
      );
end entity uart_rx;

architecture rtl of uart_rx is
  constant k_timeperbit   : real := real(1)/real(g_baudRate);
  constant k_clkperiod    : real := real(1)/real(g_clkRate);
  constant k_clksPerBit   : integer := integer(real(g_clkRate)/real(g_baudRate));
  constant k_clksPerBitd2 : integer := integer(real(k_clksPerBit)/real(2));
  constant k_TBits        : unsigned(3 downto 0) := to_unsigned(10,4);

  -- Outputs 
  signal f_rx_data     : std_logic_vector(7 downto 0) := (others => '0');
  signal f_rx_data_rdy : std_logic := '0';
  
  type sm_rxUart is (s_idle, s_cfmLow, s_rxStartBit, s_rx8bits, s_parity, s_stop, s_reset);
  signal f_cState : sm_rxUart := s_idle;
  
  signal f_clkCount : integer := 0;
  signal f_rxBits   : unsigned(3 downto 0) := (others => '0');
  
begin
  p_rxctrl : process(i_clk) 
  begin
    if rising_edge(i_clk) then
      o_rx_data_rdy <= f_rx_data_rdy;
      o_rx_data <= f_rx_data;
      case f_cState is
        when s_idle => 
          f_rx_data_rdy <= '0';
          f_rx_data <= (others => '0');
          if i_rx = '0' then
            f_cState <= s_cfmLow;
          end if;
        when s_cfmLow =>
          if f_clkCount = k_clksPerBitd2 then
            if i_rx = '0' then
              f_cState <= s_rxStartBit;
              f_clkCount <= 0;  
            else 
              f_cState <= s_idle; -- if rx line isn't still low during start bit.
              f_clkCount <= 0;
            end if;
          else
            f_clkCount <= f_clkCount + 1;
          end if;
        when s_rxStartBit =>
          if f_clkCount = k_clksPerBit then
            f_cState <= s_rx8bits;
            f_rx_data(to_integer(f_rxBits)) <= i_rx;
            f_rxBits <= f_rxBits + 1;
            f_clkCount <= 0;
          else 
            f_clkCount <= f_clkCount + 1;
          end if;        
        when s_rx8bits =>
          if f_rxBits = 8 then
            f_cState <= s_parity;
          elsif f_clkCount = k_clksPerBit then 
            f_clkCount <= 0;
            f_rx_data(to_integer(f_rxBits)) <= i_rx;
            f_rxBits <= f_rxBits + 1;
          else 
            f_clkCount <= f_clkCount + 1;
          end if;
        when s_parity =>
          if f_clkCount = k_clksPerBit then
            f_rxBits <= (others => '0');
            f_clkCount <= 0;
            if i_rx = '1' then
              f_cState <= s_stop;
            else
              f_cState <= s_idle;
            end if;
          else
            f_clkCount <= f_clkCount + 1;
          end if;
        when s_stop => 
          if f_clkCount = k_clksPerBit then
            f_clkCount <= 0;
            if i_rx = '1' then
              f_cState <= s_reset;
            else
              f_cState <= s_idle;
            end if;
          else
            f_clkCount <= f_clkCount + 1;
          end if;
        when s_reset =>
          if f_clkCount = k_clksPerBitd2 then
            f_rx_data_rdy <= '1';
            f_cState <= s_idle;
            f_rxBits <= (others => '0');
          else
            f_clkCount <= f_clkCount + 1;
          end if;
      end case; 
    end if;
  end process;
end rtl;
\end{VHDLlisting}

The five states of the state machine are idle, start, check start, acquire bits, and stop. As a side note state machines can use more resources. If you really wanted to squeeze out all the resources needed then you could rewrite the below code to not use a state machine and save some resources.The first state is s\_idle. In this state we are only concerned with whether or not the data has started. To start a UART transaction the data line is deasserted. We will use a falling edge detection circuit to determine is if the transaction has started. Once the falling edge is detected we move to s\_check.

In s\_check we count a half a bit's duration. The half a bit duration ensures we are sampling at the middle of a bit window. Since the clocks at the transmitter and receiver aren't synchronized we need to sample in the middle of the bit to gain the most reliable data. Once we have counted half a bits duration we can check that the start bit is low, if not we reset back to s\_idle, however if the start bit is low we go to s\_getbits.

In s\_getbits we will receive all the bits in a UART transaction. The number of bits in a transaction is variable but the most common is a byte or eight bits. So, after the start bit is confirmed to be low and we transition to this state we need to wait a full bit duration and sample the data line. We store the sampled data in a shift register. Once we have counted up the number of bits we continue on the the s\_stop state. In the s\_stop state we make sure the data line is high after the next but duration. Some configurations of the UART protocol have a parity bit. In this state is where you calculate the parity and check the integrity of the received data. 

\begin{VHDLlisting}[tabsize=8]
library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;
  use ieee.math_real.all;
  
entity uart_tx is
  generic(g_baudRate : integer := 115200;
          g_clkRate  : integer := 50000000);
  port(
      i_clk        : in    std_logic;
      i_sclr       : in    std_logic;
      i_tx_data    : in    std_logic_vector(7 downto 0);
      i_tx_data_dv : in    std_logic;
      o_tx         :   out std_logic;
      o_tx_busy    :   out std_logic
      );
end uart_tx;
architecture rtl of uart_tx is 
  constant k_timeperbit : real := real(1)/real(g_baudRate);
  constant k_clkperiod  : real := real(1)/real(g_clkRate);
  constant k_clksPerBit : integer := integer(real(g_clkRate)/real(g_baudRate)); 
  constant k_TBits      : unsigned(3 downto 0) := to_unsigned(10,4);
  
  type sm_uarttx_ctrl is (s_idle, s_txing, s_reset);
  signal f_cState : sm_uarttx_ctrl := s_idle;
  
  signal f_data2Tx : std_logic_vector(10 downto 0) := (others => '0');
  signal f_clkCount: integer := 0;
  signal f_bitCount: unsigned(3 downto 0) := (others => '0');
  
  -- Register Outs
  signal f_tx : std_logic := '1';
  signal f_tx_busy : std_logic := '0';
begin
  p_ctrl : process(i_clk) 
  begin
    if i_sclr = '1' then
        f_data2Tx <= (others => '0');
    elsif rising_edge(i_clk) then
      o_tx <= f_tx;
      o_tx_busy <= f_tx_busy;
      case f_cState is  
        when s_idle =>
          if i_tx_data_dv = '1' then
            f_data2Tx(8 downto 1) <= i_tx_data;
            f_data2Tx(10 downto 9) <= b"11";
            f_tx <= '0';
            f_tx_busy <= '1';
            f_cState <= s_txing;
            f_bitCount <= f_bitCount + 1;
          end if;
        when s_txing => 
          if f_clkCount = k_clksPerBit then
            f_clkCount <= 0;
            f_tx <= f_data2Tx(to_integer(f_bitCount));
            f_bitCount <= f_bitCount + 1;
            if f_bitCount = k_TBits then
              f_cState <= s_reset;
            end if;
          else
            f_clkCount <= f_clkCount + 1;
          end if;
        when s_reset => 
          f_tx <= '1';
          f_tx_busy <= '0';
          f_cState <= s_idle;
          f_bitCount <= (others => '0');
      end case;
    end if;
  end process;
end rtl;
\end{VHDLlisting}
	
The \ac{UART} transmitter operates in a similar fashion. The transmitter's job is is ensure the data is put on the line with the same timing the receiver expects. The data in loaded into the core in parallel but it output with a shift register. After a bit duration has passed we shift another bit out of the shift register until all the bits are sent. Then the transaction is ended.
	

\subsection{Serial Peripheral Interface (SPI)}
	<TODO Subsection Serial Peripheral Interface (SPI) : NOT DONE>

\ac{SPI} is commonly used for inter-chip communication where a chip is configured by a SPI master. The SPI master initiates all traffic between the SPI master and SPI slave. The slave chip only responses to commands from the master. The SPI bus consists of four wires; clock, chip select, input data, and output data. Since there is a clock we know this protocol is synchronous. The clock is driven by the master and the clock rate is the only way to change the data rate of the communications. In general the \ac{SPI} bus is capable of a higher data rate than the UART.

The rest of the lines generally work as follows but some chips use a slight variation to the descriptions below. General SPI code can be altered to meet specific chip standards. The datasheet for the chip you are trying to interface to should be consulted to ensure proper operation. 

The \ac(CS) line is used to enable communications with the chip. The reason for the name is that you can reuse the same clock and data lines but change only the CS lines for configuring multiple chips. In this way you save \ac{IO} pins on the \ac{FPGA}. The CS line is used to indicate that communication is starting. \ac{CS} can be active low or active high. Usually with active low signals an \emph{n} is appended to the name so if our CS line were active low it could be called CSn. 

The last lines of the SPI bus to discuss are the data lines. These lines are named \ac{MOSI} and \ac{MISO}. The names of course tell you the direction and who drives the pins. Sometimes if \ac{IO} pins are limited there is a shared data line. This is possible because it is understood that the master controls communication if the master is reading data from the slave then the master releases control of the data line in time for the slave to control the line. Care must be taken to ensure that there isn't contention on the line. If both slave and master drive the pin communication will fail. 	

Next we can look at an implementation of a \ac{SPI}-Master. Shown here

\begin{VHDLlisting}[tabsize=4]
-- spi_master.vhd

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;
	
entity spi_master is
	generic(g_sclkrate  : integer;
			g_word_size : integer)
	port(i_clk      : in    std_logic;
		 i_rst      : in    std_logic;
		 
		 o_spi_clk  :   out std_logic;
		 o_spi_mosi :   out std_logic;
		 i_spi_miso : in    std_logic;
		 o_spi_ncs  :   out std_logic;
		
		 i_rd_nwr   : in    std_logic;
		 i_wrdataen : in    std_logic;
		 i_wr_data  : in    std_logic_vector(g_word_size-1 downto 0);
		
		 o_rd_data  :   out std_logic_vector(g_word_size-1 downto 0);
		 o_rd_dv    :   out std_logic;
		 o_busy     :   out std_logic	
	);
end entity spi_master;

architecture rtl of spi_master is
	signal f_clk_counter : unsigned(31 downto 0);
	signal f_o_sclk      : std_logic := '0';
	signal f_o_mosi      : std_logic := '0';
	signal f_o_ncs       : std_logic := '0';
	
	signal f_o_rd_dv     : std_logic := '0';
	signal f_rd_data     : std_logic_vector(g_word_size-1 downto 0);
	
	type sm_spi is (s_idle, s_transfer, s_end);
	signal s_spi         : sm_spi := s_idle;
	
	signal f_wr_data     : std_logic_vector(g_word_size-1 downto 0);
	signal f_rx_data     : std_logic_vector(g_word_size-1 downto 0);
	
	signal f_data_c      : unsigned(7 downto 0);
	signal f_data_rd_c   : unsigned(7 downto 0);
	
	
begin

	o_busy      <= f_busy;
	o_spi_clk   <= f_o_sclk; 
    o_spi_mosi  <= f_o_mosi;
    o_spi_ncs   <= f_o_ncs; 
	
	o_rd_data <= f_o_rd_dv;
	o_rd_dv   <= f_rd_data;

	p_gen_sclk : process(i_clk)
	begin
		if rising_edge(i_clk) then
			if i_rst = '1' then
				f_clk_counter <= (others => '0');
			else
				f_clk_counter <= f_clk_counter + 1;
				if f_clk_counter = g_sclkrate then
					f_o_sclk <= '0';
					f_clk_counter <= (others => '0');
				elsif f_clk_counter = g_sclkrate/2 then
					f_o_sclk <= '1';
				end if;
			end if;		
		end if;
	end process;

	p_launch_data : process(i_clk)
	begin
		if rising_edge(i_clk) then
			if i_rst = '1' then
				s_spi <= s_idle;
				f_busy <= '0';
				f_o_ncs <= '1';
			else
				ff_o_sclk <= f_o_sclk;
				case s_spi is
					when idle =>
						f_busy <= '0';
						f_o_ncs <= '1';
						f_o_rd_dv <= '1';
						if i_wrdataen = '1' then
							s_spi <= s_transfer;
							f_wr_data <= i_wr_data;
							f_busy <= '1';
							f_rd_nwr <= i_rd_nwr;
							f_data_c <= to_unsigned(f_wr_data'high,f_data_c'length);
							f_data_rd_c <= (others => '0');
						end if;
					when s_transfer => 
						-- Falling Edge of SCLK
						if ff_o_sclk = '1' and f_o_sclk = '0' then
							f_o_ncs <= '0';
							f_o_mosi <= f_wr_data(to_integer(f_data_c));
							f_data_c <= f_data_c - 1;
							if f_data_c = 0 then
								f_data_c <= to_unsigned(f_wr_data'high,f_data_c'length);
								s_spi <= s_end;
							end if;
						end if;					

						-- Rising Edge of SCLK
						if ff_o_sclk = '0' and f_o_sclk = '1' then
							f_rx_data(to_integer(f_data_rd_c)) <= i_spi_miso;
							f_data_rd_c <= f_data_rd_c + 1;
						end if;
					when s_end => 
						s_spi <= s_idle;
						if f_rd_nwr = '1' then
							-- Reading data from slave
							f_o_rd_dv <= '1';
							f_rd_data <= f_rx_data;
						end if;				
				end case;
			end if;
		end if;	
	end process;


end rtl;
\end{VHDLlisting}

This \ac{VHDL} uses a state machine to control when the data is sent and received. We see in the first process the \ac{SPI} clock is generated and sent out the \emph{SCLK} port. There may be certain circumstances where you don't want to clock always running. You can gate the output of the clock with the busy signal to ensure they clock is running only when it is needed. 

Looking closer at the \ac{VHDL} first we see we use two generics. The first generic is \emph{g\_sclkrate}, which is used to determine the \ac{SPI} clock speed. The \ac{SPI} clock speed is the clock speed of i\_clk divided by \emph{g\_sclkrate}. So if we have a $100$\ac{MHz} clock input and \emph{g\_sclkrate} is $4$ then \emph{o\_spi\_clk} will have a frequency of $25$\ac{MHz}. The generic helps us use the same spi\_master code for different chips that have different interfacing speeds. 

Next we have a the generic \emph{g\_word\_size}. The generic determines the number of bits being transferred in one transaction. The ports of our entity first list our clock and reset signals. Then we have the four \ac{IO} pins for the \ac{SPI} protocol. Then we have a flag that says whether we are writing data to the slave or reading data from the slave. Next we have the write data and write data valid. Followed by the read data and read data valid. And lastly we have a busy signal that lets the instantiating core know that we are currently busy spending out data. This is important because in one clock cycle the \ac{SPI}-Master is given \emph{g\_word\_size} data bits, but many clock cycles later, depending on the \ac{SPI} clock speed, the transfer is complete. 

Next we look in the architecture of the \ac{SPI}-Master and in the first process of the architecture we generate the \ac{SPI} clock, denoted \emph{f\_o\_sclk}. We use a counter that counts up to \emph{g\_sclkrate}. As the counter gets to half of \emph{g\_sclkrate} we deassert the clock then when we reach \emph{g\_sclkrate} we assert the clock. 

The next process launches data on the \ac{SPI} bus. First we wait in the state \emph{s\_idle} until write data valid is asserted. Whether we are reading data from the slave or writing data to the slave we have to start the transaction by have the master enable the \ac{CS} line. The amount of data includes the amount of data that will be read back from the slave as well. Usually the \ac{SPI} master writes an address and the rest of the data is the data at the specified address.

Once data is loaded into the \ac{SPI}-Master the state machine transitions to the \emph{s\_transfer} state. In this state we first look for the falling edge of the \ac{SPI} clock, at which, we assign data to the \ac{MOSI} line starting with the \ac{MSB}. We wait for falling edges over and over again until we have launched all the data. Then we transition to the \emph{s\_end} state. But also in the \emph{s\_transfer} state we look for the rising edge of the \ac{SPI} clock. Here we register what is coming in on the \ac{MISO} line. 

Once we are in the \emph{s\_end} state we go back to \emph{s\_idle}, but before we do if we were performing a read operation then we set the outputs providing valid data at the output ports. 

Now we should go back and discuss the reasoning for using the rising edge and falling edge of the \ac{SPI} clock. We launch the data on the falling edge of the \ac{SPI} clock because we want to have the maximum possible time for the data to be stable when the receiver of the data samples it at the rising edge. Just like when we wait for the rising edge of the clock to register the input we want the data to be stable. 

\subsection{Inter-Integrated Circuit (I2C) Bus}
	<TODO Subsection Inter-Integrated Circuit (I2C) Bus : NOT DONE>

The \ac{I2C} bus communication protocol is similar to the \ac{SPI} interface in that it is used for inter chip communication. The major advantage to \ac{I2C} is that is uses half the lines as \ac{SPI}. You may be thinking who cares about the number of \ac{IO} pins a chip takes but this can be an issue with interfacing to a few peripherals, especially when a few of them are high speed \ac{LVDS}. In this case saving a few \ac{IO} pins per chip is necessary to ensure \ac{IO} pins are available for a high speed \ac{ADC} or \ac{DDR} memory chip. 	
	
In the \ac{I2C} bus there are two wires, clock and data. And similar to \ac{SPI} each chip that you interface to will have a different clock speed and signal timing associated with the chip. For the \ac{I2C} example we show what happens when we know the chip has 32 bits per transaction. 	
	
In the \ac{I2C} protocol data is sent in eight bit chunks. So to interface to the 32 bit transaction size we break the transaction down into four - eight bit sections and ensure we have an acknowledge bit at the end of each eight bit section. 
	
We can look at some example code to see how this is done in \ac{VHDL}.	

\begin{VHDLlisting}[tabsize=4]
-- i2c_write.vhd

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;


entity i2c_write is
    port(i_clk        : in    std_logic;
         i_rst        : in    std_logic;
         -- I2C Ports 
         b_sda        : inout std_logic;
         o_scl        :   out std_logic;
         -- App 
         i_data       : in    std_logic_vector(31 downto 0);
         i_dv         : in    std_logic;
         o_busy       :   out std_logic
    );
end entity i2c_write;

architecture rtl of i2c_write is 
    constant k_start_cond     : integer := 144;
	
    constant k_clks_per_scl_h : integer := 500;
    constant k_clks_per_scl   : integer := k_clks_per_scl_h*2;
	constant k_end_cond       : integer := 144 + k_clks_per_scl_h;
	
    -- Input Regs
    signal f_data    : std_logic_vector(31 downto 0) := (others => '0');
    	
    -- Output Regs
    signal f_busy    : std_logic := '0';
    signal f_sda     : std_logic := '1';
    signal f_scl     : std_logic := '1';

	constant k_n_data_frames : integer := 3;
    signal f_cc      : unsigned(11 downto 0) := (others => '0');
    signal f_os      : unsigned(7 downto 0) := (others => '0');
	signal f_ndframes: unsigned(3 downto 0) := (others => '0');
    signal f_ack_bit : std_logic := '1';
	signal f_done    : std_logic := '0';

    type sm_states is (s_idle, s_init_frame, s_reset_start_cond, s_ack_bit, s_write_data_frame, s_end);
    signal s_i2c  : sm_states := s_idle;
begin

    o_busy <= f_busy;

    b_sda <= f_sda;
    o_scl <= f_scl;

    p_i2c : process(i_clk)
    begin
        if rising_edge(i_clk) then
            if i_rst = '1' then
                s_i2c <= s_idle;
				f_sda <= '1';
                f_scl <= '1';
				f_done <= '0';
            else
                case s_i2c is
                    when s_idle => 
                        f_sda <= '1';a
                        f_scl <= '1';
						f_done <= '0';
						f_ack_bit <= '1';
						f_os <= to_unsigned(31,8);
                        if i_dv = '1' then
                            f_data <= i_data;
                            s_i2c <= s_init_frame;
                            f_sda <= '0'; -- Assumes point to point I2C
                            f_busy <= '1';
                        end if;
                    when s_init_frame => 
                        -- Start Condition deassert SDA
                        f_cc <= f_cc + 1;
                        if f_cc = k_start_cond then
                            f_cc <= (others => '0');
                            f_scl <= '0';
                            f_sda <= f_data(to_integer(f_os));
                            s_i2c <= s_write_data_frame;
                        end if;
					when s_reset_start_cond => 
						f_cc <= f_cc + 1;
						f_sda <= '1';
                        if f_cc = k_end_cond then
                            f_cc <= (others => '0');
							s_i2c <= s_init_frame;
                            f_sda <= '0';
                        end if;
                    when s_ack_bit => 
                        f_cc <= f_cc + 1;
                        if f_cc = k_clks_per_scl_h then
                            f_scl <= '1';
                            f_ack_bit <= b_sda;
                        end if; 
                        if f_cc = k_clks_per_scl then
							f_scl <= '0';
							f_cc <= (others => '0');
                            if f_ack_bit = '0' then
                                -- Success
								if f_done = '0' then
									s_i2c <= s_write_data_frame;
									f_sda <= f_data(to_integer(f_os));
								else
									f_sda <= '0';
									s_i2c <= s_end;
								end if;
                            else
                                -- Fail -- Reset
                                s_i2c <= s_idle;
                            end if;
                        end if;
                    when s_write_data_frame => 
                        f_cc <= f_cc + 1;
						f_ack_bit <= '1';
						
                        if f_cc = k_clks_per_scl_h then
                            f_scl <= '1';
                            f_os <= f_os - 1;
                        end if; 
						
                        if f_cc = k_clks_per_scl then
							f_scl <= '0';
                            f_cc <= (others => '0');
							if f_os = 23 then
								f_sda <= 'Z';
								s_i2c <= s_ack_bit;
								f_done <= '0';
                            elsif f_os = 15 then
								f_sda <= 'Z';
								s_i2c <= s_ack_bit;
								f_done <= '0';
                            elsif f_os = 7 then
								f_sda <= 'Z';
								s_i2c <= s_ack_bit;
								f_done <= '0';
                            elsif f_done = '1' then
								f_sda <= 'Z';
                                s_i2c <= s_ack_bit;
							else
								f_sda <= f_data(to_integer(f_os));
								if f_os = 0 then
									f_done <= '1';
								end if;
                            end if;
                        end if;
					when s_end =>
						f_cc <= f_cc + 1;
						if f_cc = k_clks_per_scl_h then
                            f_scl <= '1';
                        end if; 
						
                        if f_cc = k_end_cond then
                            f_cc <= (others => '0');
							f_sda <= '1';
							s_i2c <= s_idle;
                        end if;
                end case;
            end if;
        end if;
    end process;
end rtl;
\end{VHDLlisting}

For this implementation we know that we are going to send $32$ bits so we don't need a generic to specify the data width. As far as the other inputs of the block we have the system clock as well as the reset line. The two \ac{I2C} lines clock and data. And finally the data the send with a data valid flag and a busy signal. 

For the \ac{I2C} implementation we again start off the state \emph{s\_idle}. Once $32$ bits are provided to the core with the data valid flag we move to the \emph{s\_init\_frame}. In this state we set the timing between the deassertion of SDA and the falling edge of the clock. This timing is specified in the data sheet for the chip that you will be interfacing to. 

Next we start the data frame in \emph{s\_write\_data\_frame}. Where we set the current bit of \emph{f\_data} to the output on the falling edge. Then after each eight bit section we jump to \emph{s\_ack\_bit} which ensure data is being sent successfully to the \ac{I2C}-Slave.

Finally after sending all $32$ bits the done flag is asserted and we end the transaction. 
	
	
\subsection{Texas Instruments universal Parallel Port (uPP)}
	<TODO Subsection Texas Instruments universal Parallel Port (uPP) : NOT DONE>
	
A \ac{TI}-\ac{DSP} is an embedded processor that specializes in operations specific to signal processing. What that means is that the \ac{MAC} structure is used often in \ac{FIR} filter design, calculating \ac{FFT}s, and even some matrix multiplication calculations. The \ac{DSP} is equipped with with the ability to perform parallel \ac{MAC} operations. Depending on the specific processor you can expect eight parallel \ac{MAC} operations. 

The \ac{DSP} a very powerful processing platform with the added hardware to the ease of development in the C programming language. Because of these reasons is it popular to interface a \ac{DSP} to an \ac{FPGA}. With both chips on a \ac{PCB} you get the best of both worlds. 

\section{Data Processing Projects}
	<TODO Section Data Processing Projects : NOT DONE>

\subsection{Strassen's Matrix Multiplication}
	<TODO Subsection Strassen's Matrix Multiplication : NOT DONE>

\subsection{Knapsack Problem}
	<TODO Subsection Knapsack Problem : NOT DONE>

\subsection{Digital Signal Processing}
	<TODO Subsection Digital Signal Processing : NOT DONE>

\subsubsection{Finite Impulse Response Filter}
	<TODO Subsubsection  Finite Impulse Response Filter : NOT DONE>

\subsubsection{Numerically Controlled Oscillator}
	<TODO Subsubsection  Numerically Controlled Oscillator : NOT DONE>

\section{Security in Hardware}
	<TODO Section Security in Hardware : NOT DONE>
hardware virus is hard. 
